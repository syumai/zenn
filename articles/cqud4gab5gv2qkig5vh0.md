---
title: Go 1.23で登場！イテレータについて知っておくべきこと
emoji: 🍓
type: "tech"
topics: ["Go"]
published: false
---

# はじめに

2024年8月13日、[Go 1.23がリリース](https://go.dev/blog/go1.23)され、ついにイテレータが利用可能となりました。
この記事では、Goのイテレータについて、

* 具体的にどうやって使うのか
* どこまで知っておく必要があるのか

を理解することをゴールとします。

# 基本的な知識

基本的な知識としては、以下の内容を知っていれば問題ないです。

* for文のrangeループの仕様が変わった
  - 関数を対象にrangeループを回せるようになる
  - rangeループの対象にできる種類の関数を**イテレータ**と呼ぶ
* イテレータには3種類ある

## for文のrangeループの仕様が変わった

Go 1.22までは、for文によるrangeループの対象にできたのは、配列, slice, 文字列, map, channel, 整数だけでした。
Go 1.23で、ここに関数（ただし、特定の形式に限る）が加わりました。

ここで、rangeループの対象にできる形式の関数を **イテレータ関数**[^1] (以下、イテレータ) と呼びます。

[^1]: イテレータは単なる俗称ではなく、仕様中でも[iterator](https://go.dev/ref/spec#For_range)と記載されている箇所があります。

## イテレータには3種類ある

イテレータには値の返し方が異なる、3つの種類があります。

1. ループごとに値を返さない
2. ループごとに1つの値を返す (channel, 整数に対するrangeループと同じ)
3. ループごとに2つの値を返す (slice, mapなどに対するrangeループと同じ)

それぞれ、以下の形式の関数となります。

```go
// 1
func(func() bool)
// 2
func(func(V) bool)
// 3
func(func(K, V) bool)
```

2, 3のケースで、 `V` と `K` には任意の型を使うことができ、rangeループではその型の値をそれぞれ受け取ります。

```go
// 1
var f1 func(func() bool)
for range f1 {} // 値が何も返らないので、 x := range f1 の形式では書けない
// 2
var f2 func(func(int) bool)
for x := range f2 {} // xはint型
// 3
var f3 func(func(string, int) bool)
for x, y := range f3 {} // xはstring型、yはint型
```

2, 3と同じ形式の関数の型が標準ライブラリの[iter package](https://pkg.go.dev/iter)に定義されているので、1のパターン以外は基本的にはこれらを使うことになります。

```go
// 2: func(func(V) bool)
iter.Seq[V any] func(yield func(V) bool)
// 3: func(func(K, V) bool)
iter.Seq2[K, V any] func(yield func(K, V) bool)
```

実際のrangeループの例として、文字列のsliceから `iter.Seq[string]` と `iter.Seq2[int, string]` を生成する `slices.Values` と `slices.All` の使用例を紹介します。

```go
s := []string{"a","b","c"}

it1 := slices.Values(s) // iter.Seq[string] 型
for v := range it1 {
  fmt.Println(v) // a, b, c が順番に表示される
}

it2 := slices.All(s) // iter.Seq2[int, string] 型
for i, v := range it2 {
  fmt.Println(i, v) // 0 a, 1 b, 2 c が順番に表示される
}
```

https://go.dev/play/p/GLogItFxBo9

# イテレータの基本的な考え方

## データ構造の隠蔽

イテレータはただの関数なので、どんなデータ構造も隠蔽できます。
すなわち、**任意のデータ構造を対象にrangeループが使えるようになります**。
ただし、イテレータはインタフェースではなく関数なので、任意のデータ構造をそのままの型（構造体など）で使うことはできません。rangeループで使うためには、**対象のデータ構造を元にした関数を生成する**必要があります。

値の集合や、値の列を表すデータ構造には色々ありますが、Go 1.23以降の世界では、それらを**イテレータに変換する関数やメソッドが各ライブラリから提供されるようになっていく**はずです。

## イテレータは、sliceよりも一般的なデータ列の形式

Go 1.22までの世界では、sliceがデータ列を表現する最も柔軟なデータ形式でした。しかしながら、データ構造によっては、sliceの利用が効率的ではないケースや、そもそも表現できないケースが存在します。

sliceがイテレータと異なる点は、データ列の長さ分のメモリが最低でも必要な点と、データ列に終わりがある点です。例えば、循環リストに対してrangeループを回したい時、このデータ列には終わりがないので、sliceに変換することができません。他には、全要素を集めてsliceにするとメモリを膨大に使ってしまうものの、元のデータ構造をそのまま使って一つずつ要素を取得していく分には効率的なケースもあるでしょう。

以上の通り、**イテレータはsliceよりも多くのケースに対応できる、より一般的なデータ列の形式**と言えます。そして、Go 1.23以降では、データ列の操作は基本的にイテレータを対象に行う形が想定されます。利用ライブラリなどとの兼ね合いで、一部、データ列をsliceとして扱う必要のある操作もあるでしょう。そういったケースでは、**slices packageを使って、sliceとイテレータを相互変換して使う**形になります。

# イテレータの使い方

イテレータには、主に2つの使い方があります。

1. rangeループで使う
2. イテレータを受け取る関数に渡す

1 については前述の通りで、sliceやmapのrangeループと特に使い方が変わりません。
2 が、sliceやmapとは大きく変わってくる点です。
イテレータを受け取る関数

# slices / maps packageの使い方

# どこまで知っておく必要があるのか
