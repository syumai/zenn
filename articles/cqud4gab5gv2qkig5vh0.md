---
title: Go 1.23で登場！イテレータについて知っておくべきこと
emoji: 🍓
type: "tech"
topics: ["Go"]
published: false
---

# はじめに

2024年8月13日、[Go 1.23がリリース](https://go.dev/blog/go1.23)され、ついにイテレータが利用可能となりました。
この記事では、Goのイテレータについて、

* 具体的にどうやって使うのか
* どこまで知っておく必要があるのか

を理解することをゴールとします。

# 基本的な知識

基本的な知識としては、以下の内容を知っていれば問題ないです。

* for文のrangeループの仕様が変わった
  - 関数を対象にrangeループを回せるようになる
  - rangeループの対象にできる種類の関数を**イテレータ**と呼ぶ
* イテレータには3種類ある

## for文のrangeループの仕様が変わった

Go 1.22までは、for文によるrangeループの対象にできたのは、配列, slice, 文字列, map, channel, 整数だけでした。
Go 1.23で、ここに関数（ただし、特定の形式に限る）が加わりました。

ここで、rangeループの対象にできる形式の関数を**イテレータ関数**[^1] (以下、イテレータ) と呼びます。

[^1]: イテレータは単なる俗称ではなく、仕様中でも[iterator](https://go.dev/ref/spec#For_range)と記載されている箇所があります。

## イテレータには3種類ある

イテレータには値の返し方が異なる、3つの種類があります。

1. イテレーションごとに値を返さない
2. イテレーションごとに1つの値を返す (channel, 整数に対するrangeループと同じ)
3. イテレーションごとに2つの値を返す (slice, mapなどに対するrangeループと同じ)

それぞれ、以下の形式の関数となります。

```go
// 1
func(func() bool)
// 2
func(func(V) bool)
// 3
func(func(K, V) bool)
```

2, 3のケースで、 `V` と `K` には任意の型を使うことができ、rangeループではその型の値をそれぞれ受け取ります。

```go
// 1
var f1 func(func() bool)
for range f1 {} // 値が何も返らないので、 x := range f1 の形式では書けない
// 2
var f2 func(func(int) bool)
for x := range f2 {} // xはint型
// 3
var f3 func(func(string, int) bool)
for x, y := range f3 {} // xはstring型、yはint型
```

2, 3と同じ形式の関数の型が標準ライブラリの[iter package](https://pkg.go.dev/iter)に定義されているので、1のパターン以外は基本的にはこれらを使うことになります。

```go
package iter

// 2: func(func(V) bool)
type Seq[V any] func(yield func(V) bool)
// 3: func(func(K, V) bool)
type Seq2[K, V any] func(yield func(K, V) bool)
```

実際のrangeループの例として、文字列のsliceから `iter.Seq[string]` と `iter.Seq2[int, string]` を生成する `slices.Values` と `slices.All` の使用例を紹介します。

```go
s := []string{"a","b","c"}

it1 := slices.Values(s) // iter.Seq[string] 型
for v := range it1 {
  fmt.Println(v) // a, b, c が順番に表示される
}

it2 := slices.All(s) // iter.Seq2[int, string] 型
for i, v := range it2 {
  fmt.Println(i, v) // 0 a, 1 b, 2 c が順番に表示される
}
```

https://go.dev/play/p/GLogItFxBo9

# Goのイテレータとは結局何なのか

筆者の認識では、Goのイテレータは**「任意のデータ構造を隠蔽してデータ列として扱うための、一般的な形式」**です。

これについて少し掘り下げて説明します。

## データ構造の隠蔽

Goのイテレータはただの関数なので、どんなデータ構造も隠蔽できます。
すなわち、**任意のデータ構造を対象にrangeループが使えるようにできます**。
ただし、イテレータはインタフェースではないので、任意のデータ構造をそのままの型（構造体など）で使うことはできません。rangeループで使うためには、**対象のデータ構造を隠蔽した関数を生成する**必要があります。

値の集合や、値の列を表すデータ構造には色々ありますが、Go 1.23以降の世界では、それらを**イテレータに変換する関数やメソッドが各ライブラリから提供されるようになっていく**はずです。

## イテレータはsliceよりも一般的なデータ列の形式

Go 1.22までの世界では、sliceがデータ列を表現する最も柔軟なデータ形式でした。しかしながら、データ構造によっては、sliceの利用が効率的ではないケースや、そもそも表現できないケースが存在します。

sliceがイテレータと異なる点は、データ列の長さ分のメモリが最低でも必要な点と、データ列に終わりがある点です。例えば、循環リストに対してrangeループを回したい時、このデータ列には終わりがないので、sliceに変換することができません。他には、全要素を集めてsliceにするとメモリを膨大に使ってしまうものの、元のデータ構造をそのまま使って一つずつ要素を取得していく分には効率的なケースもあるでしょう。

以上の通り、**イテレータはsliceよりも多くのケースに対応できる、より一般的なデータ列の形式**と言えます。そして、Go 1.23以降では、データ列の操作は基本的にイテレータを対象に行う形が想定されます。使用ライブラリなどとの兼ね合いで、一部、データ列をsliceとして扱う必要のある操作もあるでしょう。そういったケースでは、**slices packageを使って、sliceとイテレータを相互変換して使う**形になります。

一つ、注意しておくべき点として、イテレータにはイテレーションごとに値を返さない形式があります。この種類のイテレータをデータ列と呼ぶべきかどうかは少々怪しいです。Goのイテレータは、全体としては「データ列の一般的な形式」と言うより、「繰り返し処理の継続と中断」を一般化したものとして捉えた方がよいかもしれません。ただ、基本的な理解としては、イテレータのほとんどのユースケースに対応するであろう「データ列の一般的な形式」として捉えてしまってよいと筆者は考えています。

# イテレータの使い方

イテレータには、主に2つの使い方があります。

1. rangeループで使う
2. イテレータを受け取る関数に渡す

1 については前述の通りで、sliceやmapのrangeループと特に使い方が変わりません。
2 が、sliceやmapとは大きく変わってくる点です。

イテレータを受け取る関数の代表的な役割は以下の通りです。

1. データ列の変換
   - いわゆるMap操作
2. データ列の集約
3. データ列の結合

## データ列の変換

この種類の関数は、データ列に含まれる各要素を別の要素に変換を行います。

簡単な例としては、文字列のストリームを受け取って、全て大文字に変換して返すものが考えられます。

```go
func ToUpper(it iter.Seq[string]) iter.Seq[string] {
	/* 実装は省略 */
}

func main() {
	s := []string{"a", "b", "c"}

	for _, v := range s {
		fmt.Println(v) // a, b, c
	}

	for v := range ToUpper(slices.Values(s)) {
		fmt.Println(v) // A, B, C
	}
}
```

上記の例において、ToUpper関数はslice `s`の全容をを一度に全ては読み取らず、一つずつ順番に取り出して処理するため効率的です。
また、文字列を要素とする、slice以外の任意のデータ列に対して適用可能となっています。

データ列を効率的に扱えると言う点で、`io.Reader`と、それに対するWrapperに近いですが、`io.Reader`がバイト列を返すストリームであるのに対し、イテレータは任意の型の値をデータ列に含む事が出来る点で大きく異なります。

## データ列の集約

```go
```

# slices / maps packageの使い方

# どこまで知っておく必要があるのか
